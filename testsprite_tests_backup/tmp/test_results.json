[
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "dccb8283-0918-4ebd-b9b1-472e3287ba5e",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC001-signup_should_fail_on_duplicate_email_or_username",
    "description": "Test the /auth/signup endpoint to ensure that user registration fails when attempting to sign up with an email or username that already exists in the system, enforcing unique user identity.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nSIGNUP_URL = f\"{BASE_URL}/auth/signup\"\nTIMEOUT = 30\n\ndef signup_should_fail_on_duplicate_email_or_username():\n    # Generate unique email and username for initial signup\n    unique_suffix = str(uuid.uuid4())\n    user_data = {\n        \"email\": f\"testuser{unique_suffix}@example.com\",\n        \"username\": f\"testuser{unique_suffix}\",\n        \"password\": \"SecureP@ssword123\",\n        \"name\": \"Test User\"\n    }\n    \n    created_user = None\n    try:\n        # First signup attempt should succeed\n        resp = requests.post(SIGNUP_URL, json=user_data, timeout=TIMEOUT)\n        assert resp.status_code == 201 or resp.status_code == 200, f\"Expected 200 or 201, got {resp.status_code}\"\n        created_user = resp.json()\n\n        # Second signup attempt with SAME email should fail\n        duplicate_email_data = {\n            \"email\": user_data[\"email\"],\n            \"username\": f\"diffusername{unique_suffix}\",\n            \"password\": \"AnotherP@ssword123\",\n            \"name\": \"Another User\"\n        }\n        resp_email_dup = requests.post(SIGNUP_URL, json=duplicate_email_data, timeout=TIMEOUT)\n        assert resp_email_dup.status_code == 400 or resp_email_dup.status_code == 409, \\\n            f\"Expected 400 or 409 for duplicate email, got {resp_email_dup.status_code}\"\n\n        # Second signup attempt with SAME username should fail\n        duplicate_username_data = {\n            \"email\": f\"diffemail{unique_suffix}@example.com\",\n            \"username\": user_data[\"username\"],\n            \"password\": \"AnotherP@ssword123\",\n            \"name\": \"Another User\"\n        }\n        resp_username_dup = requests.post(SIGNUP_URL, json=duplicate_username_data, timeout=TIMEOUT)\n        assert resp_username_dup.status_code == 400 or resp_username_dup.status_code == 409, \\\n            f\"Expected 400 or 409 for duplicate username, got {resp_username_dup.status_code}\"\n\n    finally:\n        # Cleanup is not possible via API deletion endpoint as per PRD, so skip deletion\n\n        # If there was an admin or user deletion endpoint this is where we would clean up.\n        pass\n\nsignup_should_fail_on_duplicate_email_or_username()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 53, in <module>\n  File \"<string>\", line 33, in signup_should_fail_on_duplicate_email_or_username\nAssertionError: Expected 400 or 409 for duplicate email, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.023Z",
    "modified": "2025-12-16T05:54:23.406Z"
  },
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "1c45ccd5-ff8e-4361-8eaf-824082f0c037",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC002-login_should_return_jwt_on_correct_credentials_and_401_on_incorrect_password",
    "description": "Test the /auth/login endpoint to verify that a JWT token is returned when correct email and password are provided, and a 401 Unauthorized error is returned when the password is incorrect.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_login_should_return_jwt_on_correct_credentials_and_401_on_incorrect_password():\n    signup_url = f\"{BASE_URL}/auth/signup\"\n    login_url = f\"{BASE_URL}/auth/login\"\n    headers = {\"Content-Type\": \"application/json\"}\n\n    test_email = \"testuser_login@example.com\"\n    test_username = \"testuser_login\"\n    test_password = \"correct_password\"\n    test_name = \"Test User Login\"\n\n    # Step 1: Create a new user to test login against\n    signup_payload = {\n        \"email\": test_email,\n        \"username\": test_username,\n        \"password\": test_password,\n        \"name\": test_name\n    }\n\n    try:\n        signup_resp = requests.post(signup_url, json=signup_payload, headers=headers, timeout=TIMEOUT)\n        assert signup_resp.status_code == 201 or signup_resp.status_code == 409, (\n            f\"Unexpected signup status code: {signup_resp.status_code}, response: {signup_resp.text}\"\n        )\n    except requests.RequestException as e:\n        raise AssertionError(f\"Signup request failed: {e}\")\n\n    # Step 2: Login with correct credentials and assert JWT in response\n    login_payload_correct = {\n        \"email\": test_email,\n        \"password\": test_password\n    }\n    try:\n        login_resp = requests.post(login_url, json=login_payload_correct, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, (\n            f\"Login with correct credentials failed with status {login_resp.status_code}, response: {login_resp.text}\"\n        )\n        json_resp = login_resp.json()\n        assert \"access_token\" in json_resp, \"JWT token not found in login response\"\n        token = json_resp.get(\"access_token\")\n        assert isinstance(token, str) and len(token) > 10, \"JWT token appears invalid\"\n    except requests.RequestException as e:\n        raise AssertionError(f\"Login request with correct credentials failed: {e}\")\n\n    # Step 3: Login with incorrect password and assert 401 Unauthorized response\n    login_payload_incorrect = {\n        \"email\": test_email,\n        \"password\": \"incorrect_password\"\n    }\n    try:\n        login_resp_bad = requests.post(login_url, json=login_payload_incorrect, headers=headers, timeout=TIMEOUT)\n        assert login_resp_bad.status_code == 401, (\n            f\"Login with incorrect password did not return 401, got {login_resp_bad.status_code}, response: {login_resp_bad.text}\"\n        )\n    except requests.RequestException as e:\n        raise AssertionError(f\"Login request with incorrect password failed: {e}\")\n\ntest_login_should_return_jwt_on_correct_credentials_and_401_on_incorrect_password()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 26, in test_login_should_return_jwt_on_correct_credentials_and_401_on_incorrect_password\nAssertionError: Unexpected signup status code: 500, response: {\"statusCode\":500,\"message\":\"Internal server error\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.034Z",
    "modified": "2025-12-16T05:54:09.115Z"
  },
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "83797aeb-448b-4af0-a765-5de70845eaa5",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC003-get_user_profile_should_be_case_insensitive_and_return_following_status",
    "description": "Test the /users/{username} GET endpoint to ensure that user profile retrieval is case-insensitive and accurately reflects the following status of the requesting user.",
    "code": "import requests\nimport string\nimport random\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef random_string(length=8):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\ndef signup_user(email, username, password, name):\n    url = f\"{BASE_URL}/auth/signup\"\n    payload = {\n        \"email\": email,\n        \"username\": username,\n        \"password\": password,\n        \"name\": name\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef login_user(email, password):\n    url = f\"{BASE_URL}/auth/login\"\n    payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    token = data.get(\"access_token\") or data.get(\"token\") or data.get(\"jwt\") or data.get(\"jwtToken\")\n    assert token, \"Login response did not contain a JWT token\"\n    return token\n\ndef follow_user(auth_token, user_id_to_follow):\n    url = f\"{BASE_URL}/users/{user_id_to_follow}/follow\"\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    resp = requests.post(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef unfollow_user(auth_token, user_id_to_unfollow):\n    url = f\"{BASE_URL}/users/{user_id_to_unfollow}/follow\"\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef get_user_profile(auth_token, username):\n    url = f\"{BASE_URL}/users/{username}\"\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n    return resp\n\ndef test_get_user_profile_should_be_case_insensitive_and_return_following_status():\n    # Create two users: user A (requesting user) and user B (target user)\n    email_a = f\"{random_string(5)}@example.com\"\n    username_a = random_string(8)\n    password_a = \"Password123!\"\n    name_a = \"User A\"\n    \n    email_b = f\"{random_string(5)}@example.com\"\n    username_b = random_string(8)\n    password_b = \"Password123!\"\n    name_b = \"User B\"\n\n    token_a = None\n\n    try:\n        # Sign up user A and user B\n        signup_user(email_a, username_a, password_a, name_a)\n        signup_user(email_b, username_b, password_b, name_b)\n\n        # Login user A and user B to get JWT tokens\n        token_a = login_user(email_a, password_a)\n        token_b = login_user(email_b, password_b)\n\n        # Get user profiles to obtain IDs\n        resp_profile_a = get_user_profile(token_a, username_a)\n        resp_profile_b = get_user_profile(token_a, username_b)\n\n        assert resp_profile_a.status_code == 200, \"Failed to get profile for user A\"\n        assert resp_profile_b.status_code == 200, \"Failed to get profile for user B\"\n\n        user_a_profile = resp_profile_a.json()\n        user_b_profile = resp_profile_b.json()\n\n        user_a_id = user_a_profile.get(\"id\")\n        user_b_id = user_b_profile.get(\"id\")\n\n        assert user_a_id is not None, \"Profile response for user A missing 'id'\"\n        assert user_b_id is not None, \"Profile response for user B missing 'id'\"\n\n        # user A follows user B\n        follow_user(token_a, user_b_id)\n\n        # Test case insensitivity: create variants of username_b with mixed case\n        username_variants = [\n            username_b.upper(),\n            username_b.lower(),\n            username_b.capitalize(),\n            username_b.swapcase()\n        ]\n\n        for variant in username_variants:\n            response = get_user_profile(token_a, variant)\n            assert response.status_code == 200, \\\n                f\"Expected 200 OK for username variant '{variant}', got {response.status_code}\"\n            profile_data = response.json()\n            assert \"username\" in profile_data, \"Response missing 'username'\"\n            assert profile_data[\"username\"].lower() == username_b.lower(), \\\n                f\"Username in response '{profile_data['username']}' does not match requested '{variant}' case-insensitively\"\n            assert \"following\" in profile_data, \"'following' field missing in profile response\"\n            assert profile_data[\"following\"] is True, \\\n                f\"'following' status should be True as user A follows user B for variant '{variant}'\"\n\n        # Additionally test a username variant that user A does NOT follow (own profile)\n        response_self = get_user_profile(token_a, username_a.upper())\n        assert response_self.status_code == 200, \"Expected 200 OK for user's own profile\"\n        profile_self = response_self.json()\n        assert profile_self[\"username\"].lower() == username_a.lower()\n        assert \"following\" in profile_self\n        # Following status for own profile should be False or omitted, check False if present\n        if profile_self.get(\"following\") is not None:\n            assert profile_self[\"following\"] is False, \"User should not be 'following' themselves\"\n\n    finally:\n        # Cleanup: unfollow user B if token exists\n        if token_a and user_b_id:\n            try:\n                unfollow_user(token_a, user_b_id)\n            except Exception:\n                pass\n\n        # Cleanup users if delete user endpoint existed\n        # Since no delete user endpoint specified in PRD, skipping user deletion\n\ntest_get_user_profile_should_be_case_insensitive_and_return_following_status()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 83, in test_get_user_profile_should_be_case_insensitive_and_return_following_status\nAssertionError: Failed to get profile for user A\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 139, in <module>\n  File \"<string>\", line 130, in test_get_user_profile_should_be_case_insensitive_and_return_following_status\nUnboundLocalError: cannot access local variable 'user_b_id' where it is not associated with a value\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.041Z",
    "modified": "2025-12-16T05:54:58.363Z"
  },
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "cd14e808-89cd-4d2b-aa97-9658aee7baa5",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC004-update_user_profile_should_persist_changes_and_handle_avatar_cover_uploads",
    "description": "Test the /users/profile PATCH endpoint to verify that profile updates are persisted correctly and that avatar and cover image uploads are handled properly.",
    "code": "import requests\nimport io\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\n\ndef test_update_user_profile_should_persist_changes_and_handle_avatar_cover_uploads():\n    # Step 1: Sign up a new user\n    signup_data = {\n        \"email\": \"testuser_tc004@example.com\",\n        \"username\": \"testuser_tc004\",\n        \"password\": \"TestPass123!\",\n        \"name\": \"Test User TC004\"\n    }\n    signup_resp = requests.post(\n        f\"{BASE_URL}/auth/signup\", json=signup_data, timeout=TIMEOUT\n    )\n    assert signup_resp.status_code == 201, f\"Signup failed: {signup_resp.text}\"\n    # Step 2: Login to get JWT token\n    login_data = {\n        \"email\": signup_data[\"email\"],\n        \"password\": signup_data[\"password\"]\n    }\n    login_resp = requests.post(\n        f\"{BASE_URL}/auth/login\", json=login_data, timeout=TIMEOUT\n    )\n    assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n    token = login_resp.json().get(\"access_token\")\n    assert token, \"JWT token missing in login response\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Prepare sample avatar and cover image bytes (simple PNG header + minimal content)\n    avatar_bytes = (\n        b\"\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x00\\x00\\x01\\x08\\x06\\x00\\x00\\x00\\x1f\\x15\\xc4\\x89\"\n        b\"\\x00\\x00\\x00\\nIDATx\\xdacd\\xf8\\x0f\\x00\\x01\\x01\\x01\\x00\"\n        b\"\\x18\\xdd\\x03\\xed\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\"\n    )\n    cover_bytes = avatar_bytes  # reuse same minimal image for cover\n\n    # Step 3: Upload avatar image\n    avatar_files = {'file': ('avatar.png', io.BytesIO(avatar_bytes), 'image/png')}\n    upload_avatar_resp = requests.post(\n        f\"{BASE_URL}/uploads\", files=avatar_files, headers=headers, timeout=TIMEOUT\n    )\n    assert upload_avatar_resp.status_code == 201, f\"Avatar upload failed: {upload_avatar_resp.text}\"\n    avatar_url = upload_avatar_resp.json().get(\"url\")\n    assert avatar_url and avatar_url.strip(), \"Avatar URL missing in upload response\"\n\n    # Step 4: Upload cover image\n    cover_files = {'file': ('cover.png', io.BytesIO(cover_bytes), 'image/png')}\n    upload_cover_resp = requests.post(\n        f\"{BASE_URL}/uploads\", files=cover_files, headers=headers, timeout=TIMEOUT\n    )\n    assert upload_cover_resp.status_code == 201, f\"Cover upload failed: {upload_cover_resp.text}\"\n    cover_url = upload_cover_resp.json().get(\"url\")\n    assert cover_url and cover_url.strip(), \"Cover URL missing in upload response\"\n\n    # Step 5: Patch the user profile with updated data including avatar and cover URLs\n    updated_profile_data = {\n        \"name\": \"Updated Test User TC004\",\n        \"bio\": \"This is a bio updated by automated test TC004.\",\n        \"location\": \"Test Location\",\n        \"website\": \"https://example.com/tc004\",\n        \"avatar\": avatar_url,\n        \"cover\": cover_url\n    }\n    patch_resp = requests.patch(\n        f\"{BASE_URL}/users/profile\", json=updated_profile_data, headers=headers, timeout=TIMEOUT\n    )\n    assert patch_resp.status_code == 200, f\"Profile update failed: {patch_resp.text}\"\n    patch_resp_json = patch_resp.json()\n    for key, val in updated_profile_data.items():\n        assert patch_resp_json.get(key) == val, f\"Profile field '{key}' mismatch\"\n\n    # Step 6: Retrieve profile to verify persistence\n    profile_resp = requests.get(\n        f\"{BASE_URL}/users/{signup_data['username']}\", headers=headers, timeout=TIMEOUT\n    )\n    assert profile_resp.status_code == 200, f\"Get profile failed: {profile_resp.text}\"\n    profile_json = profile_resp.json()\n    for key, val in updated_profile_data.items():\n        assert profile_json.get(key) == val, f\"Persisted profile field '{key}' mismatch\"\n\n    # Cleanup: Delete the test user (assuming there's a delete profile or user endpoint)\n    try:\n        resp = requests.delete(f\"{BASE_URL}/users/profile\", headers=headers, timeout=TIMEOUT)\n        assert resp.status_code in (200, 204), f\"Cleanup delete user failed: {resp.text}\"\n    except Exception:\n        # If no delete endpoint, pass\n        pass\n\n\ntest_update_user_profile_should_persist_changes_and_handle_avatar_cover_uploads()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 98, in <module>\n  File \"<string>\", line 19, in test_update_user_profile_should_persist_changes_and_handle_avatar_cover_uploads\nAssertionError: Signup failed: {\"statusCode\":500,\"message\":\"Internal server error\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.048Z",
    "modified": "2025-12-16T05:54:14.802Z"
  },
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "9470ff8c-1d35-444f-9d7b-598c4fcf1e81",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC005-follow_user_should_prevent_self_follow_and_update_follower_counts",
    "description": "Test the /users/{id}/follow POST endpoint to ensure users cannot follow themselves and that follower counts update correctly after following another user.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef signup_user(email, username, password, name):\n    url = f\"{BASE_URL}/auth/signup\"\n    payload = {\n        \"email\": email,\n        \"username\": username,\n        \"password\": password,\n        \"name\": name\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef login_user(email, password):\n    url = f\"{BASE_URL}/auth/login\"\n    payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    json_resp = resp.json()\n    # The token may be under 'token' or 'accessToken'; assert at least one is present\n    token = json_resp.get(\"token\") or json_resp.get(\"accessToken\")\n    assert token is not None, f\"Login response missing token field: {json_resp}\"\n    return token\n\ndef get_user_profile(username, token):\n    url = f\"{BASE_URL}/users/{username}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef post_follow_user(user_id, token):\n    url = f\"{BASE_URL}/users/{user_id}/follow\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.post(url, headers=headers, timeout=TIMEOUT)\n    return resp\n\ndef delete_user(user_id, token):\n    # No delete user endpoint described in PRD, so skip deleting created users\n    pass\n\ndef test_follow_user_should_prevent_self_follow_and_update_follower_counts():\n    # Create two distinct users for this test\n    unique_suffix1 = uuid.uuid4().hex[:8]\n    unique_suffix2 = uuid.uuid4().hex[:8]\n    email1 = f\"user1_{unique_suffix1}@example.com\"\n    username1 = f\"user1_{unique_suffix1}\"\n    password1 = \"Password123!\"\n    name1 = \"User One\"\n\n    email2 = f\"user2_{unique_suffix2}@example.com\"\n    username2 = f\"user2_{unique_suffix2}\"\n    password2 = \"Password123!\"\n    name2 = \"User Two\"\n\n    # Signup user1\n    signup_user(email1, username1, password1, name1)\n    token1 = login_user(email1, password1)\n    user1_profile = get_user_profile(username1, token1)\n    user1_id = user1_profile.get(\"id\") or user1_profile.get(\"userId\")\n    assert user1_id is not None, \"User1 creation failed: no user id returned\"\n\n    # Signup user2\n    signup_user(email2, username2, password2, name2)\n    token2 = login_user(email2, password2)\n    user2_profile = get_user_profile(username2, token2)\n    user2_id = user2_profile.get(\"id\") or user2_profile.get(\"userId\")\n    assert user2_id is not None, \"User2 creation failed: no user id returned\"\n\n    try:\n        # user1 tries to follow self - should fail\n        resp = post_follow_user(user1_id, token1)\n        assert resp.status_code == 400 or resp.status_code == 403, \\\n            f\"Expected 400 or 403 when user follows self, got {resp.status_code}\"\n        # We expect error message about self-follow prevented\n        error_json = resp.json()\n        assert \"cannot follow yourself\" in str(error_json).lower() or \"self\" in str(error_json).lower(), \\\n            \"Expected error message about self-follow prevention\"\n\n        # Get user2 profile before follow to check follower count\n        profile_before = get_user_profile(username2, token1)\n        followers_before = profile_before.get(\"followersCount\", profile_before.get(\"followers\", 0))\n\n        # user1 follows user2 - success expected\n        resp = post_follow_user(user2_id, token1)\n        assert resp.status_code == 200, f\"Expected 200 OK when following another user, got {resp.status_code}\"\n\n        # Get user2 profile after follow to check follower count incremented\n        profile_after = get_user_profile(username2, token1)\n        followers_after = profile_after.get(\"followersCount\", profile_after.get(\"followers\", 0))\n\n        assert followers_after == followers_before + 1, \\\n            f\"Follower count did not increment correctly: before={followers_before}, after={followers_after}\"\n\n        # Also verify that user1's following count increments if available\n        profile1 = get_user_profile(username1, token1)\n        following_before = profile1.get(\"followingCount\", profile1.get(\"following\", 0))\n        # Ideally following count should have updated but may not if cache delay; so just check >= 1\n        assert following_before >= 1, \\\n            f\"User1 following count seems incorrect: {following_before}\"\n\n    finally:\n        # Cleanup users if deletion API was available\n        # No user deletion endpoint info so skipping actual delete\n        pass\n\ntest_follow_user_should_prevent_self_follow_and_update_follower_counts()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 115, in <module>\n  File \"<string>\", line 66, in test_follow_user_should_prevent_self_follow_and_update_follower_counts\n  File \"<string>\", line 30, in login_user\nAssertionError: Login response missing token field: {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InVzZXIxX2ZhN2QyOGM5QGV4YW1wbGUuY29tIiwic3ViIjoiY21qODY0bzNsMDAwdGg1OWlhZXJpdWN5aSIsImlhdCI6MTc2NTg2NDUwMCwiZXhwIjoxNzY1ODY4MTAwfQ.7H4u2ox1i2NVgb19bEp1TuqoOiV3tC2qMnpu1CF8vZQ', 'user': {'id': 'cmj864o3l000th59iaeriucyi', 'email': 'user1_fa7d28c9@example.com', 'name': 'User One', 'username': 'user1_fa7d28c9', 'bio': None, 'avatar': None, 'coverImage': None, 'createdAt': '2025-12-16T05:54:59.457Z', 'updatedAt': '2025-12-16T05:54:59.457Z', 'verified': False}}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.055Z",
    "modified": "2025-12-16T05:55:00.460Z"
  },
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "e7ebe5a7-9c3f-43cb-aec3-5f0f6f25145a",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC006-unfollow_user_should_update_follower_counts_correctly",
    "description": "Test the /users/{id}/follow DELETE endpoint to verify that unfollowing a user updates follower counts correctly.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef signup_user(email, username, password, name):\n    url = f\"{BASE_URL}/auth/signup\"\n    payload = {\n        \"email\": email,\n        \"username\": username,\n        \"password\": password,\n        \"name\": name\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    json_resp = resp.json()\n    assert \"id\" in json_resp, \"Signup response missing expected 'id' field\"\n    return json_resp\n\ndef login_user(email, password):\n    url = f\"{BASE_URL}/auth/login\"\n    payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    json_resp = resp.json()\n    assert \"token\" in json_resp, \"Login response missing 'token'\"\n    return json_resp[\"token\"]\n\ndef get_user_profile(username, token):\n    url = f\"{BASE_URL}/users/{username}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef follow_user(user_id, token):\n    url = f\"{BASE_URL}/users/{user_id}/follow\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.post(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp\n\ndef unfollow_user(user_id, token):\n    url = f\"{BASE_URL}/users/{user_id}/follow\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp\n\ndef unfollow_user_should_update_follower_counts_correctly():\n    # Create two users: follower and followee\n    follower_email = f\"user_follower_{uuid.uuid4()}@test.com\"\n    follower_username = f\"userfollower{uuid.uuid4().hex[:8]}\"\n    follower_password = \"Password123!\"\n    follower_name = \"Follower User\"\n\n    followee_email = f\"user_followee_{uuid.uuid4()}@test.com\"\n    followee_username = f\"userfollowee{uuid.uuid4().hex[:8]}\"\n    followee_password = \"Password123!\"\n    followee_name = \"Followee User\"\n\n    try:\n        # Signup follower\n        signup_user(follower_email, follower_username, follower_password, follower_name)\n        follower_token = login_user(follower_email, follower_password)\n\n        # Signup followee\n        signup_user(followee_email, followee_username, followee_password, followee_name)\n        followee_token = login_user(followee_email, followee_password)\n\n        # Get followee profile before follow\n        followee_profile_before = get_user_profile(followee_username, follower_token)\n        followers_count_before = followee_profile_before.get(\"followersCount\", 0)\n\n        # Follower follows followee\n        followee_user_id = followee_profile_before.get(\"id\")\n        follow_resp = follow_user(followee_user_id, follower_token)\n        assert follow_resp.status_code == 200 or follow_resp.status_code == 204\n\n        # Confirm follower count incremented\n        followee_profile_after_follow = get_user_profile(followee_username, follower_token)\n        followers_count_after_follow = followee_profile_after_follow.get(\"followersCount\", 0)\n        assert followers_count_after_follow == followers_count_before + 1\n\n        # Follower unfollows followee\n        unfollow_resp = unfollow_user(followee_user_id, follower_token)\n        assert unfollow_resp.status_code == 200 or unfollow_resp.status_code == 204\n\n        # Confirm follower count decremented back\n        followee_profile_after_unfollow = get_user_profile(followee_username, follower_token)\n        followers_count_after_unfollow = followee_profile_after_unfollow.get(\"followersCount\", 0)\n        assert followers_count_after_unfollow == followers_count_before\n\n    finally:\n        # Clean up: ideally delete users but no endpoint info provided; test infra cleanup assumed\n\n        # Optionally unfollow in case of failure before unfollow\n        try:\n            unfollow_user(followee_user_id, follower_token)\n        except:\n            pass\n\n\nunfollow_user_should_update_follower_counts_correctly()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 108, in <module>\n  File \"<string>\", line 68, in unfollow_user_should_update_follower_counts_correctly\n  File \"<string>\", line 18, in signup_user\nAssertionError: Signup response missing expected 'id' field\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.062Z",
    "modified": "2025-12-16T05:54:41.327Z"
  },
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "aba099fa-ab69-4dd2-972d-ac3ed8ab2821",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC007-create_tweet_should_support_text_and_images",
    "description": "Test the /tweets POST endpoint to ensure that users can create tweets with text content and image attachments successfully.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\n\ndef create_user(email, username, password, name):\n    url = f\"{BASE_URL}/auth/signup\"\n    payload = {\n        \"email\": email,\n        \"username\": username,\n        \"password\": password,\n        \"name\": name\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef login_user(email, password):\n    url = f\"{BASE_URL}/auth/login\"\n    payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"token\" in data, \"Login response does not contain 'token'\"\n    token = data[\"token\"]\n    return token\n\n\ndef upload_image(auth_token, image_content, filename):\n    url = f\"{BASE_URL}/uploads\"\n    headers = {\n        \"Authorization\": f\"Bearer {auth_token}\"\n    }\n    files = {\n        \"file\": (filename, image_content, \"image/png\")\n    }\n    resp = requests.post(url, headers=headers, files=files, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    # Assuming API returns a JSON with URL or id of the uploaded image\n    assert \"url\" in data or \"id\" in data or \"location\" in data, \"Upload response missing expected keys\"\n    return data\n\n\ndef create_tweet(auth_token, text, media_urls=None):\n    url = f\"{BASE_URL}/tweets\"\n    headers = {\n        \"Authorization\": f\"Bearer {auth_token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\"text\": text}\n    if media_urls:\n        # Assuming the API accepts 'media' or 'images' key for attachments as list of URLs\n        payload[\"media\"] = media_urls\n    resp = requests.post(url, headers=headers, json=payload, timeout=TIMEOUT)\n    return resp\n\n\ndef delete_tweet(auth_token, tweet_id):\n    url = f\"{BASE_URL}/tweets/{tweet_id}\"\n    headers = {\n        \"Authorization\": f\"Bearer {auth_token}\"\n    }\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    return resp\n\n\ndef test_create_tweet_should_support_text_and_images():\n    # Step 1: Create a new user\n    unique_val = str(uuid.uuid4())\n    email = f\"{unique_val}@example.com\"\n    username = f\"user{unique_val[:8]}\"\n    password = \"TestPass123!\"\n    name = \"Test User\"\n\n    user = create_user(email, username, password, name)\n\n    # Step 2: Login to get auth token\n    token = login_user(email, password)\n\n    # Step 3: Upload an image to obtain a media URL\n    image_content = (\n        b\"\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x00\\x00\\x01\\x08\\x02\\x00\\x00\\x00\\x90wS\\xde\\x00\"\n        b\"\\x00\\x00\\nIDATx\\xdac\\xf8\\x0f\\x00\\x01\\x01\\x01\\x00\"\n        b\"\\x18\\xdd\\x03\\xd5\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\"\n    )\n    filename = \"test-image.png\"\n    upload_response = upload_image(token, image_content, filename)\n    # Extract URL or ID for media inclusion\n    media_url = upload_response.get(\"url\") or upload_response.get(\"location\") or upload_response.get(\"id\")\n    if not media_url:\n        raise AssertionError(\"Failed to get media URL from upload response\")\n\n    # Step 4: Create tweet with text and image media URL\n    text = \"This is a test tweet with text and image\"\n    media_urls = [media_url]\n\n    resp = None\n    tweet_id = None\n\n    try:\n        resp = create_tweet(token, text, media_urls)\n        assert resp.status_code == 201, f\"Expected 201 Created but got {resp.status_code}\"\n        data = resp.json()\n        assert \"id\" in data, \"Response missing tweet ID\"\n        assert data.get(\"text\") == text, \"Tweet text does not match\"\n        # Check that media URLs or attachments are in the response\n        if \"media\" in data:\n            assert isinstance(data[\"media\"], list)\n            assert any(media_url in (m if isinstance(m, str) else m.get(\"url\", \"\") for m in data[\"media\"])), \\\n                \"Uploaded media URL not found in the tweet media list\"\n        elif \"images\" in data:\n            assert isinstance(data[\"images\"], list)\n            assert any(media_url in (m if isinstance(m, str) else m.get(\"url\", \"\") for m in data[\"images\"])), \\\n                \"Uploaded media URL not found in the tweet images list\"\n        tweet_id = data[\"id\"]\n    finally:\n        # Clean up: delete the tweet if created\n        if tweet_id:\n            del_resp = delete_tweet(token, tweet_id)\n            # If deletion fails, at least note it (do not raise to avoid masking test result)\n            if del_resp.status_code not in (200, 204):\n                print(f\"Warning: Failed to delete tweet {tweet_id}, status code: {del_resp.status_code}\")\n\n\ntest_create_tweet_should_support_text_and_images()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 133, in <module>\n  File \"<string>\", line 85, in test_create_tweet_should_support_text_and_images\n  File \"<string>\", line 30, in login_user\nAssertionError: Login response does not contain 'token'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.068Z",
    "modified": "2025-12-16T05:55:12.587Z"
  },
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "de0459b8-326e-46b5-bbdf-46e794e4eca2",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC008-get_all_tweets_should_return_timeline_ordered_newest_first",
    "description": "Test the /tweets GET endpoint to verify that the timeline of tweets is returned ordered by newest first.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_get_all_tweets_should_return_timeline_ordered_newest_first():\n    # This test requires authentication to create a tweet (to guarantee at least 2 tweets to verify order)\n    # 1. Sign up a new user\n    signup_data = {\n        \"email\": f\"testuser_{int(time.time())}@example.com\",\n        \"username\": f\"testuser_{int(time.time())}\",\n        \"password\": \"TestPassword123!\",\n        \"name\": \"Test User\"\n    }\n    signup_resp = requests.post(f\"{BASE_URL}/auth/signup\", json=signup_data, timeout=TIMEOUT)\n    assert signup_resp.status_code == 201, f\"Signup failed: {signup_resp.text}\"\n\n    # 2. Login to obtain JWT token\n    login_data = {\n        \"email\": signup_data[\"email\"],\n        \"password\": signup_data[\"password\"]\n    }\n    login_resp = requests.post(f\"{BASE_URL}/auth/login\", json=login_data, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n\n    login_json = login_resp.json()\n    token = login_json.get(\"access_token\")\n    assert token, f\"No token returned on login: {login_resp.text}\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # 3. Create two tweets with different timestamps to verify ordering\n    tweet_ids = []\n    try:\n        tweet1_data = {\"text\": \"First tweet for ordering test\"}\n        tweet1_resp = requests.post(f\"{BASE_URL}/tweets\", json=tweet1_data, headers=headers, timeout=TIMEOUT)\n        assert tweet1_resp.status_code == 201, f\"Failed to create first tweet: {tweet1_resp.text}\"\n        tweet1_id = tweet1_resp.json().get(\"id\")\n        assert tweet1_id, \"No tweet id returned for first tweet\"\n        tweet_ids.append(tweet1_id)\n        time.sleep(1)  # Ensure different timestamp\n\n        tweet2_data = {\"text\": \"Second tweet for ordering test\"}\n        tweet2_resp = requests.post(f\"{BASE_URL}/tweets\", json=tweet2_data, headers=headers, timeout=TIMEOUT)\n        assert tweet2_resp.status_code == 201, f\"Failed to create second tweet: {tweet2_resp.text}\"\n        tweet2_id = tweet2_resp.json().get(\"id\")\n        assert tweet2_id, \"No tweet id returned for second tweet\"\n        tweet_ids.append(tweet2_id)\n\n        # 4. Fetch all tweets\n        get_tweets_resp = requests.get(f\"{BASE_URL}/tweets\", headers=headers, timeout=TIMEOUT)\n        assert get_tweets_resp.status_code == 200, f\"Failed to get tweets: {get_tweets_resp.text}\"\n        tweets = get_tweets_resp.json()\n        assert isinstance(tweets, list), \"Tweets response is not a list\"\n\n        # 5. Check that tweets are ordered newest first by comparing timestamps or order of tweet ids\n        # Here we check that tweet2 appears before tweet1 in the list\n        ids_in_response = [tweet.get(\"id\") for tweet in tweets if tweet.get(\"id\") in tweet_ids]\n        # tweet2_id should come before tweet1_id for newest first ordering\n        assert tweet2_id in ids_in_response and tweet1_id in ids_in_response, \"Test tweets not found in timeline\"\n        assert ids_in_response.index(tweet2_id) < ids_in_response.index(tweet1_id), \\\n            \"Tweets are not ordered newest first\"\n\n    finally:\n        # Cleanup: delete created tweets\n        for tid in tweet_ids:\n            requests.delete(f\"{BASE_URL}/tweets/{tid}\", headers=headers, timeout=TIMEOUT)\n        # Ideally delete user as well, but no user deletion endpoint specified\n\n\ntest_get_all_tweets_should_return_timeline_ordered_newest_first()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 75, in <module>\n  File \"<string>\", line 25, in test_get_all_tweets_should_return_timeline_ordered_newest_first\nAssertionError: Login failed: {\"access_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InRlc3R1c2VyXzE3NjU4NjQ0NzZAZXhhbXBsZS5jb20iLCJzdWIiOiJjbWo4NjQ3MmwwMDBuaDU5aWd6eWV6Ynp1IiwiaWF0IjoxNzY1ODY0NDc4LCJleHAiOjE3NjU4NjgwNzh9.AjpPRgGtf5tyhBIR3le1QsW5vm6WR3JKiYFi-yY-QfI\",\"user\":{\"id\":\"cmj86472l000nh59igzyezbzu\",\"email\":\"testuser_1765864476@example.com\",\"name\":\"Test User\",\"username\":\"testuser_1765864476\",\"bio\":null,\"avatar\":null,\"coverImage\":null,\"createdAt\":\"2025-12-16T05:54:37.389Z\",\"updatedAt\":\"2025-12-16T05:54:37.389Z\",\"verified\":false}}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.075Z",
    "modified": "2025-12-16T05:54:46.515Z"
  },
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "51225f10-b969-471f-8f4c-36fa543866bd",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC009-like_tweet_should_allow_liking_and_unliking",
    "description": "Test the /tweets/{id}/like POST and DELETE endpoints to ensure users can like and unlike tweets properly.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef signup_user(email, username, password, name):\n    url = f\"{BASE_URL}/auth/signup\"\n    payload = {\n        \"email\": email,\n        \"username\": username,\n        \"password\": password,\n        \"name\": name\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef login_user(email, password):\n    url = f\"{BASE_URL}/auth/login\"\n    payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef create_tweet(token, text):\n    url = f\"{BASE_URL}/tweets\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    payload = {\n        \"text\": text\n    }\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef delete_tweet(tweet_id, token):\n    url = f\"{BASE_URL}/tweets/{tweet_id}\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    # Accept 200 or 204 for delete success\n    if resp.status_code not in (200, 204):\n        resp.raise_for_status()\n\ndef like_tweet(tweet_id, token):\n    url = f\"{BASE_URL}/tweets/{tweet_id}/like\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    resp = requests.post(url, headers=headers, timeout=TIMEOUT)\n    return resp\n\ndef unlike_tweet(tweet_id, token):\n    url = f\"{BASE_URL}/tweets/{tweet_id}/like\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    return resp\n\ndef test_like_tweet_should_allow_liking_and_unliking():\n    # Create unique user for test\n    test_email = f\"user_{uuid.uuid4().hex}@example.com\"\n    test_username = f\"user_{uuid.uuid4().hex[:8]}\"\n    test_password = \"StrongPass!123\"\n    test_name = \"Test User\"\n    \n    user_signup_resp = signup_user(test_email, test_username, test_password, test_name)\n    assert \"accessToken\" in user_signup_resp, \"Signup should return an accessToken\"\n    token = user_signup_resp[\"accessToken\"]\n    assert token, \"JWT token must be present after signup\"\n\n    # Also verify login works (optional)\n    login_resp = login_user(test_email, test_password)\n    assert \"accessToken\" in login_resp, \"Login should return an accessToken\"\n\n    tweet = None\n    try:\n        tweet = create_tweet(token, \"Test tweet for like/unlike functionality.\")\n        assert \"id\" in tweet, \"Creating tweet should return tweet with id\"\n        tweet_id = tweet[\"id\"]\n\n        # Like the tweet\n        like_resp = like_tweet(tweet_id, token)\n        assert like_resp.status_code == 200, f\"Liking tweet failed with status {like_resp.status_code}\"\n        \n        # Verify like response content if applicable\n        if like_resp.headers.get(\"Content-Type\", \"\").startswith(\"application/json\"):\n            like_data = like_resp.json()\n            assert isinstance(like_data, dict), \"Like response should be a JSON object\"\n\n        # Unlike the tweet\n        unlike_resp = unlike_tweet(tweet_id, token)\n        assert unlike_resp.status_code == 200, f\"Unliking tweet failed with status {unlike_resp.status_code}\"\n        \n        # Verify unlike response content if applicable\n        if unlike_resp.headers.get(\"Content-Type\", \"\").startswith(\"application/json\"):\n            unlike_data = unlike_resp.json()\n            assert isinstance(unlike_data, dict), \"Unlike response should be a JSON object\"\n            \n    finally:\n        if tweet and \"id\" in tweet:\n            try:\n                delete_tweet(tweet[\"id\"], token)\n            except Exception:\n                # Cleanup failure is non-fatal to test outcome\n                pass\n\ntest_like_tweet_should_allow_liking_and_unliking()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 115, in <module>\n  File \"<string>\", line 75, in test_like_tweet_should_allow_liking_and_unliking\nAssertionError: Signup should return an accessToken\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.082Z",
    "modified": "2025-12-16T05:55:04.788Z"
  },
  {
    "projectId": "0a00a630-5e87-456b-b455-8ac772257d13",
    "testId": "561b7a85-ede1-4d5c-96e6-94bf837a057b",
    "userId": "e4688428-8031-70c9-569b-cb772aeaae2d",
    "title": "TC010-upload_file_should_succeed_for_valid_images_and_return_accessible_url",
    "description": "Test the /uploads POST endpoint to verify that uploading valid image files succeeds and returns accessible URLs for the uploaded media.",
    "code": "import requests\nimport io\n\nBASE_URL = \"http://localhost:3001\"\nUPLOAD_ENDPOINT = f\"{BASE_URL}/uploads\"\nTIMEOUT = 30\n\n\ndef upload_file_should_succeed_for_valid_images_and_return_accessible_url():\n    # Prepare a small valid PNG image byte stream (1x1 px transparent PNG)\n    png_image_bytes = (\n        b\"\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\"\n        b\"\\x08\\x06\\x00\\x00\\x00\\x1f\\x15\\xc4\\x89\\x00\\x00\\x00\\nIDATx\\x9cc`\\x00\\x00\"\n        b\"\\x00\\x02\\x00\\x01\\xe2!\\xbc\\x33\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\"\n    )\n\n    files = {\n        'file': ('test.png', io.BytesIO(png_image_bytes), 'image/png')\n    }\n\n    try:\n        response = requests.post(UPLOAD_ENDPOINT, files=files, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed with exception: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        resp_json = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Expecting returned JSON to contain an accessible URL for the uploaded media.\n    assert isinstance(resp_json, dict), \"Response JSON is not a dictionary\"\n    assert \"url\" in resp_json, \"'url' key not found in response JSON\"\n    url = resp_json[\"url\"]\n    assert isinstance(url, str) and url.startswith(\"http\"), \"Returned URL is invalid or not absolute\"\n\n    # Optional: test if the returned URL is accessible (HEAD request)\n    try:\n        head_resp = requests.head(url, timeout=TIMEOUT)\n        assert head_resp.status_code == 200, f\"Uploaded file URL not accessible, status {head_resp.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"HEAD request to uploaded file URL failed: {e}\"\n\n\nupload_file_should_succeed_for_valid_images_and_return_accessible_url()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 47, in <module>\n  File \"<string>\", line 26, in upload_file_should_succeed_for_valid_images_and_return_accessible_url\nAssertionError: Expected status code 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T05:53:10.098Z",
    "modified": "2025-12-16T05:54:46.508Z"
  }
]
